module Example exposing (..)

import Dynamic.Build as D
import Dynamic as D
import Date exposing (Date)
import Dynamic.Json
import Json.Encode
import Json.Decode


type Example
    = Constructor1 Bool Date
    | Constructor2 { d : Char, f : Float }
    | Constructor3 (List String)
    | Constructor4 Example Example
    | Constructor5 Example2


type Example2
    = ConstructorX Int


test : Example
test =
    Constructor4
        (Constructor4
            (Constructor2 { d = 'a', f = 1 })
            (Constructor1 True (Date.fromTime 0))
        )
        (Constructor4
            (Constructor3 [ "A" ])
            (Constructor5 (ConstructorX 1))
        )


run : Example -> Result String Bool
run t =
    t
        |> Dynamic.Json.encoder t_Example
        |> Json.Encode.encode 0
        |> Json.Decode.decodeString (Dynamic.Json.decoder t_Example)
        |> Result.map ((==) t)



-- CODE BELOW WOULD BE GENERATED BY COMPILER by typing #Example --


t_Example : D.Dynamic Example
t_Example =
    let
        record_d_f =
            let
                types =
                    [ ( "d", D.typ D.t_Char )
                    , ( "f", D.typ D.t_Float )
                    ]

                fromElm r =
                    D.recordFromElm
                        [ ( "d", D.fromElm D.t_Char r.d )
                        , ( "f", D.fromElm D.t_Float r.f )
                        ]

                toElm data =
                    D.recordToElm types data
                        |> Result.andThen
                            (\values ->
                                case values of
                                    [ data_d, data_f ] ->
                                        D.toElm D.t_Char data_d
                                            |> Result.andThen
                                                (\d ->
                                                    D.toElm D.t_Float data_f
                                                        |> Result.andThen
                                                            (\f ->
                                                                Ok { d = d, f = f }
                                                            )
                                                )

                                    _ ->
                                        D.internalError
                            )
            in
                D.buildRecord types [ D.unions D.t_Char, D.unions D.t_Float ] fromElm toElm

        list_String =
            D.t_List D.t_String

        t_Example2 =
            let
                types =
                    [ ( "ConstructorX", [ D.typ D.t_Int ] ) ]

                fromElm u =
                    D.unionFromElm <|
                        case u of
                            ConstructorX d1 ->
                                D.constructorFromElm "ConstructorX" [ D.fromElm D.t_Int d1 ]

                toElm data =
                    D.unionToElm types data
                        |> Result.andThen
                            (\v ->
                                case v of
                                    ( "ConstructorX", [ d1 ] ) ->
                                        D.toElm D.t_Int d1 |> Result.andThen (\v1 -> Ok (ConstructorX v1))

                                    _ ->
                                        D.internalError
                            )
            in
                D.buildUnion ( "Example2", [] ) types [ D.unions D.t_Int ] fromElm toElm

        types =
            [ ( "Constructor1", [ D.typ D.t_Bool, D.typ D.t_Date ] )
            , ( "Constructor2", [ D.typ record_d_f ] )
            , ( "Constructor3", [ D.typ list_String ] )
            , ( "Constructor4", [ D.namedType "Example" [], D.namedType "Example" [] ] )
            , ( "Constructor5", [ D.namedType "Example2" [] ] )
            ]

        fromElm u =
            D.unionFromElm <|
                case u of
                    Constructor1 v1 v2 ->
                        D.constructorFromElm "Constructor1" [ D.fromElm D.t_Bool v1, D.fromElm D.t_Date v2 ]

                    Constructor2 v1 ->
                        D.constructorFromElm "Constructor2"
                            [ D.fromElm record_d_f v1 ]

                    Constructor3 v1 ->
                        D.constructorFromElm "Constructor3"
                            [ D.fromElm list_String v1 ]

                    Constructor4 v1 v2 ->
                        D.constructorFromElm "Constructor4"
                            [ fromElm v1
                            , fromElm v2
                            ]

                    Constructor5 v1 ->
                        D.constructorFromElm "Constructor5"
                            [ D.fromElm t_Example2 v1 ]

        toElm data =
            D.unionToElm types data
                |> Result.andThen
                    (\v ->
                        case v of
                            ( "Constructor1", [ d1, d2 ] ) ->
                                D.toElm D.t_Bool d1
                                    |> Result.andThen
                                        (\v1 ->
                                            D.toElm D.t_Date d2
                                                |> Result.andThen
                                                    (\v2 -> Ok (Constructor1 v1 v2))
                                        )

                            ( "Constructor2", [ d1 ] ) ->
                                D.toElm record_d_f d1
                                    |> Result.andThen
                                        (\v1 -> Ok (Constructor2 v1))

                            ( "Constructor3", [ d1 ] ) ->
                                D.toElm list_String d1
                                    |> Result.andThen
                                        (\v1 -> Ok (Constructor3 v1))

                            ( "Constructor4", [ d1, d2 ] ) ->
                                toElm d1
                                    |> Result.andThen
                                        (\v1 ->
                                            toElm d2
                                                |> Result.andThen
                                                    (\v2 -> Ok (Constructor4 v1 v2))
                                        )

                            ( "Constructor5", [ d1 ] ) ->
                                D.toElm t_Example2 d1
                                    |> Result.andThen
                                        (\v1 ->
                                            Ok (Constructor5 v1)
                                        )

                            _ ->
                                D.internalError
                    )
    in
        D.buildUnion ( "Example", [] ) types [ D.unions D.t_Bool, D.unions D.t_Date, D.unions record_d_f, D.unions list_String, D.unions t_Example2 ] fromElm toElm
